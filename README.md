# Galactic inventory test

## ECR and docker images
The docker image for the `server` can be generated by running the `make docker` script.

The image can be uploaded to ECR (Amazon Elastic Container Registry) by using the `bash push_docker_image_to_ecr.sh <image_id>` script as detailed before.

The EKS should be able to retrieve images from ECR without requiring any secrets definition.

## Application deployment through Helm chart
The defined Helm chart will create the following:

* A k8s service account
* A k8s service which will listen in a TCP port (80 by default)
* A k8s deployment

This definition is comming by default when you create a Helm chart. The deployment can be sexucted by running the `bash deploy_helm_chart.sh` script.

**Note**: I have tested this against **minikube**.

### Deployment

```
$ kubectl describe deployment application-server
Name:                   application-server
Namespace:              default
CreationTimestamp:      Fri, 23 Jul 2021 21:19:25 +0100
Labels:                 app.kubernetes.io/instance=application
                        app.kubernetes.io/managed-by=Helm
                        app.kubernetes.io/name=server
                        app.kubernetes.io/version=1.16.0
                        helm.sh/chart=server-0.1.0
Annotations:            deployment.kubernetes.io/revision: 1
                        meta.helm.sh/release-name: application
                        meta.helm.sh/release-namespace: default
Selector:               app.kubernetes.io/instance=application,app.kubernetes.io/name=server
Replicas:               1 desired | 1 updated | 1 total | 0 available | 1 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:           app.kubernetes.io/instance=application
                    app.kubernetes.io/name=server
  Service Account:  application-server
  Containers:
   server:
    Image:      804731442997.dkr.ecr.eu-west-1.amazonaws.com/app-test:latest
    Port:       80/TCP
    Host Port:  0/TCP
    Command:
      /server/bin/server
    Args:
      -db_server
      <server_name>
      -db_port
      <server_port>
      -db_user
      
      -db_password
      <password>
      -db_name
      <database>
    Liveness:     http-get http://:http/health delay=0s timeout=1s period=10s #success=1 #failure=3
    Readiness:    http-get http://:http/health delay=0s timeout=1s period=10s #success=1 #failure=3
    Environment:  <none>
    Mounts:       <none>
  Volumes:        <none>
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      False   MinimumReplicasUnavailable
  Progressing    True    ReplicaSetUpdated
OldReplicaSets:  <none>
NewReplicaSet:   application-server-7b6dcf98f4 (1/1 replicas created)
Events:
  Type    Reason             Age   From                   Message
  ----    ------             ----  ----                   -------
  Normal  ScalingReplicaSet  85s   deployment-controller  Scaled up replica set application-server-7b6dcf98f4 to 1
```

### Service

```
$ kubectl describe service application-server
Name:              application-server
Namespace:         default
Labels:            app.kubernetes.io/instance=application
                   app.kubernetes.io/managed-by=Helm
                   app.kubernetes.io/name=server
                   app.kubernetes.io/version=1.16.0
                   helm.sh/chart=server-0.1.0
Annotations:       meta.helm.sh/release-name: application
                   meta.helm.sh/release-namespace: default
Selector:          app.kubernetes.io/instance=application,app.kubernetes.io/name=server
Type:              ClusterIP
IP Family Policy:  SingleStack
IP Families:       IPv4
IP:                10.100.55.54
IPs:               10.100.55.54
Port:              http  80/TCP
TargetPort:        http/TCP
Endpoints:         
Session Affinity:  None
Events:            <none>
```

```
$ kubectl describe serviceaccount application-server
Name:                application-server
Namespace:           default
Labels:              app.kubernetes.io/instance=application
                     app.kubernetes.io/managed-by=Helm
                     app.kubernetes.io/name=server
                     app.kubernetes.io/version=1.16.0
                     helm.sh/chart=server-0.1.0
Annotations:         meta.helm.sh/release-name: application
                     meta.helm.sh/release-namespace: default
Image pull secrets:  <none>
Mountable secrets:   application-server-token-9bmnr
Tokens:              application-server-token-9bmnr
Events:              <none>
```

## Terraform

### VPC
One VPC will be automatically created after running terraform. The VPC contains two subnets (**internal** and **public**) each will be dynamically associated with internal and external load balancers as per the defined tag.

### EKS cluster
The Elastic Cloud Kubernetes cluster will be automatically created after running terraform. The terraform output will provide the **KUBECONFIG** file necesary to connect to the cluster using `kubectl` or `helm`.

The cluster has a defined node group with instances of a scpecific type with a specific scaling configuration.

### RDS database
A single RDS database has been defined

### Plan

```
$ terraform plan

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # aws_db_instance.eks_ricardo_db will be created
  + resource "aws_db_instance" "eks_ricardo_db" {
      + address                               = (known after apply)
      + allocated_storage                     = 20
      + apply_immediately                     = (known after apply)
      + arn                                   = (known after apply)
      + auto_minor_version_upgrade            = true
      + availability_zone                     = (known after apply)
      + backup_retention_period               = (known after apply)
      + backup_window                         = (known after apply)
      + ca_cert_identifier                    = (known after apply)
      + character_set_name                    = (known after apply)
      + copy_tags_to_snapshot                 = false
      + db_subnet_group_name                  = (known after apply)
      + delete_automated_backups              = true
      + endpoint                              = (known after apply)
      + engine                                = "mysql"
      + engine_version                        = "5.7.30"
      + hosted_zone_id                        = (known after apply)
      + id                                    = (known after apply)
      + identifier                            = (known after apply)
      + identifier_prefix                     = (known after apply)
      + instance_class                        = "db.t2.micro"
      + kms_key_id                            = (known after apply)
      + latest_restorable_time                = (known after apply)
      + license_model                         = (known after apply)
      + maintenance_window                    = (known after apply)
      + monitoring_interval                   = 0
      + monitoring_role_arn                   = (known after apply)
      + multi_az                              = (known after apply)
      + name                                  = "galacticdb"
      + option_group_name                     = (known after apply)
      + parameter_group_name                  = "default.mysql5.7"
      + password                              = (sensitive value)
      + performance_insights_enabled          = false
      + performance_insights_kms_key_id       = (known after apply)
      + performance_insights_retention_period = (known after apply)
      + port                                  = (known after apply)
      + publicly_accessible                   = true
      + replicas                              = (known after apply)
      + resource_id                           = (known after apply)
      + skip_final_snapshot                   = true
      + snapshot_identifier                   = (known after apply)
      + status                                = (known after apply)
      + storage_type                          = "gp2"
      + tags                                  = {
          + "Name" = "galacticdb"
        }
      + tags_all                              = {
          + "Name" = "galacticdb"
        }
      + timezone                              = (known after apply)
      + username                              = "yoda"
      + vpc_security_group_ids                = (known after apply)
    }

  # aws_eip.eks_ricardo_vpc_nat_eip will be created
  + resource "aws_eip" "eks_ricardo_vpc_nat_eip" {
      + allocation_id        = (known after apply)
      + association_id       = (known after apply)
      + carrier_ip           = (known after apply)
      + customer_owned_ip    = (known after apply)
      + domain               = (known after apply)
      + id                   = (known after apply)
      + instance             = (known after apply)
      + network_border_group = (known after apply)
      + network_interface    = (known after apply)
      + private_dns          = (known after apply)
      + private_ip           = (known after apply)
      + public_dns           = (known after apply)
      + public_ip            = (known after apply)
      + public_ipv4_pool     = (known after apply)
      + tags                 = {
          + "Name" = "ricardo-eks-vpc-nat-eip"
        }
      + tags_all             = {
          + "Name" = "ricardo-eks-vpc-nat-eip"
        }
      + vpc                  = (known after apply)
    }

  # aws_eks_cluster.eks_ricardo will be created
  + resource "aws_eks_cluster" "eks_ricardo" {
      + arn                   = (known after apply)
      + certificate_authority = (known after apply)
      + created_at            = (known after apply)
      + endpoint              = (known after apply)
      + id                    = (known after apply)
      + identity              = (known after apply)
      + name                  = "ricardo-eks"
      + platform_version      = (known after apply)
      + role_arn              = (known after apply)
      + status                = (known after apply)
      + tags_all              = (known after apply)
      + version               = (known after apply)

      + kubernetes_network_config {
          + service_ipv4_cidr = (known after apply)
        }

      + vpc_config {
          + cluster_security_group_id = (known after apply)
          + endpoint_private_access   = false
          + endpoint_public_access    = true
          + public_access_cidrs       = (known after apply)
          + subnet_ids                = (known after apply)
          + vpc_id                    = (known after apply)
        }
    }

  # aws_eks_node_group.eks_ricardo_ng will be created
  + resource "aws_eks_node_group" "eks_ricardo_ng" {
      + ami_type               = (known after apply)
      + arn                    = (known after apply)
      + capacity_type          = (known after apply)
      + cluster_name           = "ricardo-eks"
      + disk_size              = (known after apply)
      + id                     = (known after apply)
      + instance_types         = [
          + "t2.micro",
        ]
      + node_group_name        = "ricardo-eks-ng"
      + node_group_name_prefix = (known after apply)
      + node_role_arn          = (known after apply)
      + release_version        = (known after apply)
      + resources              = (known after apply)
      + status                 = (known after apply)
      + subnet_ids             = (known after apply)
      + tags_all               = (known after apply)
      + version                = (known after apply)

      + scaling_config {
          + desired_size = 1
          + max_size     = 1
          + min_size     = 1
        }
    }

  # aws_iam_role.eks_ricardo_node_role will be created
  + resource "aws_iam_role" "eks_ricardo_node_role" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "ec2.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "ricardo-eks-node-role"
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)

      + inline_policy {
          + name   = (known after apply)
          + policy = (known after apply)
        }
    }

  # aws_iam_role.eks_ricardo_role will be created
  + resource "aws_iam_role" "eks_ricardo_role" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "eks.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "ricardo-eks-role"
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)

      + inline_policy {
          + name   = (known after apply)
          + policy = (known after apply)
        }
    }

  # aws_iam_role_policy_attachment.eks_ricardo_cni_policy will be created
  + resource "aws_iam_role_policy_attachment" "eks_ricardo_cni_policy" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy"
      + role       = "ricardo-eks-node-role"
    }

  # aws_iam_role_policy_attachment.eks_ricardo_node_policy will be created
  + resource "aws_iam_role_policy_attachment" "eks_ricardo_node_policy" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy"
      + role       = "ricardo-eks-node-role"
    }

  # aws_iam_role_policy_attachment.eks_ricardo_policy will be created
  + resource "aws_iam_role_policy_attachment" "eks_ricardo_policy" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEKSClusterPolicy"
      + role       = "ricardo-eks-role"
    }

  # aws_iam_role_policy_attachment.eks_ricardo_registry_policy will be created
  + resource "aws_iam_role_policy_attachment" "eks_ricardo_registry_policy" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"
      + role       = "ricardo-eks-node-role"
    }

  # aws_iam_role_policy_attachment.eks_ricardo_vpc_policy will be created
  + resource "aws_iam_role_policy_attachment" "eks_ricardo_vpc_policy" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEKSVPCResourceController"
      + role       = "ricardo-eks-role"
    }

  # aws_internet_gateway.eks_ricardo_vpc_ig will be created
  + resource "aws_internet_gateway" "eks_ricardo_vpc_ig" {
      + arn      = (known after apply)
      + id       = (known after apply)
      + owner_id = (known after apply)
      + tags     = {
          + "Name" = "ricardo-eks-vpc-ig"
        }
      + tags_all = {
          + "Name" = "ricardo-eks-vpc-ig"
        }
      + vpc_id   = (known after apply)
    }

  # aws_nat_gateway.nat[0] will be created
  + resource "aws_nat_gateway" "nat" {
      + allocation_id        = (known after apply)
      + connectivity_type    = "public"
      + id                   = (known after apply)
      + network_interface_id = (known after apply)
      + private_ip           = (known after apply)
      + public_ip            = (known after apply)
      + subnet_id            = (known after apply)
      + tags                 = {
          + "Name" = "ricardo-eks-vpc-nat-gw"
        }
      + tags_all             = {
          + "Name" = "ricardo-eks-vpc-nat-gw"
        }
    }

  # aws_nat_gateway.nat[1] will be created
  + resource "aws_nat_gateway" "nat" {
      + allocation_id        = (known after apply)
      + connectivity_type    = "public"
      + id                   = (known after apply)
      + network_interface_id = (known after apply)
      + private_ip           = (known after apply)
      + public_ip            = (known after apply)
      + subnet_id            = (known after apply)
      + tags                 = {
          + "Name" = "ricardo-eks-vpc-nat-gw"
        }
      + tags_all             = {
          + "Name" = "ricardo-eks-vpc-nat-gw"
        }
    }

  # aws_nat_gateway.nat[2] will be created
  + resource "aws_nat_gateway" "nat" {
      + allocation_id        = (known after apply)
      + connectivity_type    = "public"
      + id                   = (known after apply)
      + network_interface_id = (known after apply)
      + private_ip           = (known after apply)
      + public_ip            = (known after apply)
      + subnet_id            = (known after apply)
      + tags                 = {
          + "Name" = "ricardo-eks-vpc-nat-gw"
        }
      + tags_all             = {
          + "Name" = "ricardo-eks-vpc-nat-gw"
        }
    }

  # aws_route_table.eks_ricardo_vpc_ig_table will be created
  + resource "aws_route_table" "eks_ricardo_vpc_ig_table" {
      + arn              = (known after apply)
      + id               = (known after apply)
      + owner_id         = (known after apply)
      + propagating_vgws = (known after apply)
      + route            = [
          + {
              + carrier_gateway_id         = ""
              + cidr_block                 = "0.0.0.0/0"
              + destination_prefix_list_id = ""
              + egress_only_gateway_id     = ""
              + gateway_id                 = (known after apply)
              + instance_id                = ""
              + ipv6_cidr_block            = ""
              + local_gateway_id           = ""
              + nat_gateway_id             = ""
              + network_interface_id       = ""
              + transit_gateway_id         = ""
              + vpc_endpoint_id            = ""
              + vpc_peering_connection_id  = ""
            },
        ]
      + tags_all         = (known after apply)
      + vpc_id           = (known after apply)
    }

  # aws_route_table_association.eks_ricardo_vpc_ig_table_internal[0] will be created
  + resource "aws_route_table_association" "eks_ricardo_vpc_ig_table_internal" {
      + id             = (known after apply)
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }

  # aws_route_table_association.eks_ricardo_vpc_ig_table_internal[1] will be created
  + resource "aws_route_table_association" "eks_ricardo_vpc_ig_table_internal" {
      + id             = (known after apply)
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }

  # aws_route_table_association.eks_ricardo_vpc_ig_table_internal[2] will be created
  + resource "aws_route_table_association" "eks_ricardo_vpc_ig_table_internal" {
      + id             = (known after apply)
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }

  # aws_route_table_association.eks_ricardo_vpc_ig_table_public[0] will be created
  + resource "aws_route_table_association" "eks_ricardo_vpc_ig_table_public" {
      + id             = (known after apply)
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }

  # aws_route_table_association.eks_ricardo_vpc_ig_table_public[1] will be created
  + resource "aws_route_table_association" "eks_ricardo_vpc_ig_table_public" {
      + id             = (known after apply)
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }

  # aws_route_table_association.eks_ricardo_vpc_ig_table_public[2] will be created
  + resource "aws_route_table_association" "eks_ricardo_vpc_ig_table_public" {
      + id             = (known after apply)
      + route_table_id = (known after apply)
      + subnet_id      = (known after apply)
    }

  # aws_security_group.eks_ricardo_rds_sg will be created
  + resource "aws_security_group" "eks_ricardo_rds_sg" {
      + arn                    = (known after apply)
      + description            = "security group for webservers"
      + egress                 = [
          + {
              + cidr_blocks      = [
                  + "0.0.0.0/0",
                ]
              + description      = ""
              + from_port        = 0
              + ipv6_cidr_blocks = []
              + prefix_list_ids  = []
              + protocol         = "-1"
              + security_groups  = []
              + self             = false
              + to_port          = 0
            },
        ]
      + id                     = (known after apply)
      + ingress                = [
          + {
              + cidr_blocks      = [
                  + "10.0.0.0/24",
                  + "10.0.1.0/24",
                  + "10.0.2.0/24",
                ]
              + description      = "MYSQL"
              + from_port        = 3306
              + ipv6_cidr_blocks = []
              + prefix_list_ids  = []
              + protocol         = "tcp"
              + security_groups  = []
              + self             = false
              + to_port          = 3306
            },
        ]
      + name                   = "db"
      + name_prefix            = (known after apply)
      + owner_id               = (known after apply)
      + revoke_rules_on_delete = false
      + tags                   = {
          + "Name" = "rds sg"
        }
      + tags_all               = {
          + "Name" = "rds sg"
        }
      + vpc_id                 = (known after apply)
    }

  # aws_subnet.eks_ricardo_vpc_internal_subnet[0] will be created
  + resource "aws_subnet" "eks_ricardo_vpc_internal_subnet" {
      + arn                             = (known after apply)
      + assign_ipv6_address_on_creation = false
      + availability_zone               = "eu-west-1a"
      + availability_zone_id            = (known after apply)
      + cidr_block                      = "10.0.0.0/24"
      + id                              = (known after apply)
      + ipv6_cidr_block_association_id  = (known after apply)
      + map_public_ip_on_launch         = false
      + owner_id                        = (known after apply)
      + tags                            = {
          + "Name"                              = "ricardo-eks-vpc-subnet"
          + "kubernetes.io/cluster/ricardo-eks" = "shared"
          + "kubernetes.io/role/internal-elb"   = "1"
        }
      + tags_all                        = {
          + "Name"                              = "ricardo-eks-vpc-subnet"
          + "kubernetes.io/cluster/ricardo-eks" = "shared"
          + "kubernetes.io/role/internal-elb"   = "1"
        }
      + vpc_id                          = (known after apply)
    }

  # aws_subnet.eks_ricardo_vpc_internal_subnet[1] will be created
  + resource "aws_subnet" "eks_ricardo_vpc_internal_subnet" {
      + arn                             = (known after apply)
      + assign_ipv6_address_on_creation = false
      + availability_zone               = "eu-west-1b"
      + availability_zone_id            = (known after apply)
      + cidr_block                      = "10.0.1.0/24"
      + id                              = (known after apply)
      + ipv6_cidr_block_association_id  = (known after apply)
      + map_public_ip_on_launch         = false
      + owner_id                        = (known after apply)
      + tags                            = {
          + "Name"                              = "ricardo-eks-vpc-subnet"
          + "kubernetes.io/cluster/ricardo-eks" = "shared"
          + "kubernetes.io/role/internal-elb"   = "1"
        }
      + tags_all                        = {
          + "Name"                              = "ricardo-eks-vpc-subnet"
          + "kubernetes.io/cluster/ricardo-eks" = "shared"
          + "kubernetes.io/role/internal-elb"   = "1"
        }
      + vpc_id                          = (known after apply)
    }

  # aws_subnet.eks_ricardo_vpc_internal_subnet[2] will be created
  + resource "aws_subnet" "eks_ricardo_vpc_internal_subnet" {
      + arn                             = (known after apply)
      + assign_ipv6_address_on_creation = false
      + availability_zone               = "eu-west-1c"
      + availability_zone_id            = (known after apply)
      + cidr_block                      = "10.0.2.0/24"
      + id                              = (known after apply)
      + ipv6_cidr_block_association_id  = (known after apply)
      + map_public_ip_on_launch         = false
      + owner_id                        = (known after apply)
      + tags                            = {
          + "Name"                              = "ricardo-eks-vpc-subnet"
          + "kubernetes.io/cluster/ricardo-eks" = "shared"
          + "kubernetes.io/role/internal-elb"   = "1"
        }
      + tags_all                        = {
          + "Name"                              = "ricardo-eks-vpc-subnet"
          + "kubernetes.io/cluster/ricardo-eks" = "shared"
          + "kubernetes.io/role/internal-elb"   = "1"
        }
      + vpc_id                          = (known after apply)
    }

  # aws_subnet.eks_ricardo_vpc_public_subnet[0] will be created
  + resource "aws_subnet" "eks_ricardo_vpc_public_subnet" {
      + arn                             = (known after apply)
      + assign_ipv6_address_on_creation = false
      + availability_zone               = "eu-west-1a"
      + availability_zone_id            = (known after apply)
      + cidr_block                      = "10.0.100.0/24"
      + id                              = (known after apply)
      + ipv6_cidr_block_association_id  = (known after apply)
      + map_public_ip_on_launch         = true
      + owner_id                        = (known after apply)
      + tags                            = {
          + "Name"                              = "ricardo-eks-vpc-subnet"
          + "kubernetes.io/cluster/ricardo-eks" = "shared"
          + "kubernetes.io/role/elb"            = "1"
        }
      + tags_all                        = {
          + "Name"                              = "ricardo-eks-vpc-subnet"
          + "kubernetes.io/cluster/ricardo-eks" = "shared"
          + "kubernetes.io/role/elb"            = "1"
        }
      + vpc_id                          = (known after apply)
    }

  # aws_subnet.eks_ricardo_vpc_public_subnet[1] will be created
  + resource "aws_subnet" "eks_ricardo_vpc_public_subnet" {
      + arn                             = (known after apply)
      + assign_ipv6_address_on_creation = false
      + availability_zone               = "eu-west-1b"
      + availability_zone_id            = (known after apply)
      + cidr_block                      = "10.0.101.0/24"
      + id                              = (known after apply)
      + ipv6_cidr_block_association_id  = (known after apply)
      + map_public_ip_on_launch         = true
      + owner_id                        = (known after apply)
      + tags                            = {
          + "Name"                              = "ricardo-eks-vpc-subnet"
          + "kubernetes.io/cluster/ricardo-eks" = "shared"
          + "kubernetes.io/role/elb"            = "1"
        }
      + tags_all                        = {
          + "Name"                              = "ricardo-eks-vpc-subnet"
          + "kubernetes.io/cluster/ricardo-eks" = "shared"
          + "kubernetes.io/role/elb"            = "1"
        }
      + vpc_id                          = (known after apply)
    }

  # aws_subnet.eks_ricardo_vpc_public_subnet[2] will be created
  + resource "aws_subnet" "eks_ricardo_vpc_public_subnet" {
      + arn                             = (known after apply)
      + assign_ipv6_address_on_creation = false
      + availability_zone               = "eu-west-1c"
      + availability_zone_id            = (known after apply)
      + cidr_block                      = "10.0.102.0/24"
      + id                              = (known after apply)
      + ipv6_cidr_block_association_id  = (known after apply)
      + map_public_ip_on_launch         = true
      + owner_id                        = (known after apply)
      + tags                            = {
          + "Name"                              = "ricardo-eks-vpc-subnet"
          + "kubernetes.io/cluster/ricardo-eks" = "shared"
          + "kubernetes.io/role/elb"            = "1"
        }
      + tags_all                        = {
          + "Name"                              = "ricardo-eks-vpc-subnet"
          + "kubernetes.io/cluster/ricardo-eks" = "shared"
          + "kubernetes.io/role/elb"            = "1"
        }
      + vpc_id                          = (known after apply)
    }

  # aws_vpc.eks_ricardo_vpc will be created
  + resource "aws_vpc" "eks_ricardo_vpc" {
      + arn                              = (known after apply)
      + assign_generated_ipv6_cidr_block = false
      + cidr_block                       = "10.0.0.0/16"
      + default_network_acl_id           = (known after apply)
      + default_route_table_id           = (known after apply)
      + default_security_group_id        = (known after apply)
      + dhcp_options_id                  = (known after apply)
      + enable_classiclink               = (known after apply)
      + enable_classiclink_dns_support   = (known after apply)
      + enable_dns_hostnames             = (known after apply)
      + enable_dns_support               = true
      + id                               = (known after apply)
      + instance_tenancy                 = "default"
      + ipv6_association_id              = (known after apply)
      + ipv6_cidr_block                  = (known after apply)
      + main_route_table_id              = (known after apply)
      + owner_id                         = (known after apply)
      + tags                             = {
          + "Name"                              = "ricardo-eks-vpc"
          + "kubernetes.io/cluster/ricardo-eks" = "shared"
        }
      + tags_all                         = {
          + "Name"                              = "ricardo-eks-vpc"
          + "kubernetes.io/cluster/ricardo-eks" = "shared"
        }
    }

Plan: 30 to add, 0 to change, 0 to destroy.

Changes to Outputs:
  + config_map_aws_auth = (known after apply)
  + kubeconfig          = (known after apply)
```
